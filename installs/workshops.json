[{
  "_id": {
    "$oid": "62aa78b1e0c43119ba4c2acc"
  },
  "id": "example",
  "lastUpdated": {
    "$numberLong": "1653716532046"
  },
  "html": "<div class=\"page\">\n  <section class=\"container\">\n    <h1>Testing portal lazy loaded components</h1>\n    <p>Should see something under me</p>\n    <div workshop-live-example=\"solution-one\" \"file=\"workshop-live-example.html\"></div>\n  </div>\n</div>"
},{
  "_id": {
    "$oid": "62aa78c4e0c43119ba4c2ace"
  },
  "id": "route-reuse-strategy",
  "lastUpdated": {
    "$numberLong": "1653716532046"
  },
  "html": "<div class=\"page\">\n      <section class=\"container\">\n        <div class=\"mat-card\">\n          <h1>Overview</h1>\n          <p>Angular, out of the box, has a powerful router that simply displays new components when accessing different URLs within the application. However, there are situations that the default functionality of the router can fall short of meeting business requirements. Like cracking an egg, there are numerous ways to work around some of this short coming. In this workshop we are going to look at the RouteReuseStrategy and how to use it to manipulate the default functionality of the Angular router. We will cover two scenarios in this workshop that Angular developers commonly use.</p>\n        </div>\n        <div class=\"mat-card\">\n          <h1>RouteReuseStrategy</h1>\n          <p>There is an abstract class RouteReuseStrategy within Angular codebase that dictates how and when components are created, saved, and destroyed during routing lifecycle. Angular by default uses the RouteReuseStrategy.</p>\n          <p>Let's look at the default methods of the class below:</p>\n          <highlight-card [code]=\"code\"></highlight-card>\n          <div code-highlighter code=\"abstract class BaseRouteReuseStrategy implements RouteReuseStrategy {\n  shouldDetach(route: ActivatedRouteSnapshot): boolean\n  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void\n  shouldAttach(route: ActivatedRouteSnapshot): boolean\n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean\n}\" ></div>\n          <p>Directly from Angular documents:</p>\n          <p><i>This base route reuse strategy only reuses routes when the matched router configs are identical. This prevents components from being destroyed and recreated when just the fragment or query parameters change (that is, the existing component is reused).</i></p>\n          <p>Basically, component lifecycles will NOT be triggered if the component is being reused on query routes. We will talk about these methods and how we can use them to enhance the Angular router to meet our edge cases.</p>\n        </div>\n        <div class=\"mat-card\">\n          <h1>Custom Implementation</h1>\n          <p>To add a custom implementation of the RouteReuseStrategy, you need to complete this two-step process:</p>\n          <p>1. Create a class that extends the RouteReuseStrategy and then implement the required methods in order to extend the abstract class:</p>\n          <div code-highlighter code=\"export class CustomReuseStrategy extends RouteReuseStrategy {\n  shouldDetach(route: ActivatedRouteSnapshot): boolean { return false; }\n  store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void { }\n  \n  shouldAttach(route: ActivatedRouteSnapshot): boolean { return false; }  \n  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null { return null; }\n  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\"></div>\n          <p><i>Note: The methods' logic we added is the same as the default Angular logic.</i></p>\n          <p>2. Create a provider to inject your custom class in your application's main module:</p>\n          <div code-highlighter code=\"@NgModule({\n  ...\n  providers: [\n    { provide: RouteReuseStrategy, useClass: CustomReuseStrategy }\n]})\"></div>\n          <p><i>Important to note that when adding a route strategy as a provider, you must ONLY do so in the top-level component's module.</i></p>\n        </div>\n        <div class=\"mat-card\">\n          <h1>Example Situation</h1>\n          <p>A common situation in web applications is a parent-detail relationship. Where some “parent” page (e.g. search results) is displaying a list of items which the user can click to view the details. Using this pattern, we are going to set a few limitations on how we want the application to perform:</p>\n          <ul>\n            <li>The parent page should have some state that should be preserved between viewing details (such as sorting, filtering, etc.)</li>\n            <li>The detail is viewable via a distinct URL containing an ID for the detail record.</li>\n            <li>The detail view should load the detail's content and be able to run some initialization logic.</li>\n            <li>The components will need to run cleanup code when destroyed such as unsubscribing from observables.</li>\n          </ul>\n          <p>We will implement two common design patterns used in Angular development. Each will have drawbacks. In those areas, we will use our custom RouteReuseStrategy to fill in those gaps.</p>\n        </div>\n        <div class=\"mat-card\">\n          <h1>Shared Components</h1>\n          <p>Both approaches will use the same detail component and will extent a base class for the parent pages. These examples will share as much logic as possible between the scenarios to help focus on the different approaches rather than the component's logic.</p>\n          <p><b>Shared Parent Class</b><br>The base abstract class to be used by the parent pages:</p>\n          <highlight-card [code]=\"code4\"></highlight-card>\n          <p>There are a few things happening in this component to take note of:</p>\n          <ol>\n            <li>OnInit we are generating a list of random numbers to emulate state.</li>\n            <li>OnDestroy we are logging an identifier to emulate a teardown of an observable</li>\n          </ol>\n          <p><b>Shared Detail Component</b><br>Both approaches will use the same detail component:</p>\n          <highlight-card [code]=\"code5\"></highlight-card>\n          <p>There are a few things happening in this component to take note of:</p>\n          <ol>\n            <li>OnInit we get the route parameters from the URL to display in the view - this emulates any data loading for the detail from a back-end service</li>\n            <li>Also generates a new random value to display in the view - this represents some view initialization for the detail page</li>\n            <li>OnDestroy same as the shared parent class logging an identifier</li>\n          </ol>\n        </div>\n\t      <next-page title=\"Next Section: Parent-Child Design\" icon=\"arrow_forward\" click-event=\"1\"></next-page>\n      </section>\n    </div>"
}]